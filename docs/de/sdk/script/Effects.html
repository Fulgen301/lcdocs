<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="stylesheet" type="text/css" href="../../doku.css">
<title>Effekte</title>
<?php 
  $g_page_language = 'german';
  require_once('../../../webnotes/core/api.php');
  pwn_head();
?><script type="text/javascript">
  function switchLanguage() {
    var loc = window.location.href;
    if (loc.match(/\/en\//)) loc = loc.replace(/\/en\//, "/de/");
    else loc = loc.replace(/\/de\//, "/en/");
    window.location = loc;
  }
</script>
</head>
<body>
<ul class="nav">
<li class="fineprint">Clonk Entwicklermodus Dokumentation</li>
<li class="switchlang"><a href="javascript:switchLanguage()"><img src="/deco/dco_en_sml.gif" alt="English" border="0"></a></li>
<li><a href="../../sdk/index.html">Einleitung</a></li>
<li><a href="../../content.html">Inhalt</a></li>
<li><a href="../../search.php">Suche</a></li>
<li><a href="../../sdk/console.html">Engine</a></li>
<li><a href="../../sdk/cmdline.html">Kommandozeile</a></li>
<li><a href="../../sdk/files.html">Spieldaten</a></li>
<li><a href="../../sdk/script/index.html">Script</a></li>
</ul>


<h1>Effekte</h1>

	<div class="text">Ab CE ist es möglich, an jedes Objekt variable Mengen an Zusatzeffekten zu binden ohne dafür zusätzliche Objekte zu benötigen. Dieses System ist besonders für Zauber interessant.</div>

	<h2 id="Intro">Einleitung</h2>
	<div class="text">Effekte sind, grob gesehen, dynamische Timer, die sich an ein Zielobjekt binden lassen. Effekte an sich bieten keinerlei graphische oder akustische Funktionen - dafür sind Partikel oder Objekte zuständig - sondern sind eine reine Scripthilfe. Zudem liefern sie ein allgemeines Interface, über das sich Statusveränderungen an Objekten untereinander abstimmen lassen.</div>
	<div class="text">Dazu ein Beispiel eines Unsichtbarkeitszaubers ohne Effekte:</div>

	<pre class="code"><i>/* Unsichtbarkeitszauber ohne Effektsystem */</i>

<b>#strict</b>

<b>local</b> iRestTime; <i>// Zeit, die der Zauber noch aktiv ist
</i><b>local</b> pTarget;   <i>// Unsichtbar gemachter Clonk
</i><b>local</b> iOldVisibility; <i>// Vorheriger Sichtbarkeitsstatus
</i><b>local</b> iOldModulation; <i>// Vorherige Farbmodulation
</i>
<b>public</b> <b>func</b> Activate(pCaster, pCaster2)
{
  <i>// Zauberer ermitteln
</i>  <b>if</b> (pCaster2) pCaster = pCaster2; pTarget = pCaster;
  <i>// Magie kann man hören, ganz klar ;)
</i>  Sound(<i class="string">"Magic*"</i>);
  <i>// Vorherige Sichtbarkeit des Zauberers speichern
</i>  iOldVisibility = GetVisibility(pCaster);
  iOldModulation = GetClrModulation(pCaster);
  <i>// Zauberer unsichtbar machen
</i>  SetVisibility(VIS_Owner() | VIS_Allies() | VIS_God(), pCaster);
  <i>// Halbdurchsichtig bläulich für den Besitzer und Verbündete
</i>  SetClrModulation(ModulateColor(iOldModulation, RGBa(127,127,255,127)), pCaster);
  <i>// Timer starten: 30 Sekunden unsichtbar
</i>  iRestTime = 30;
}

<b>protected</b> <b>func</b> TimerCall()
{
  <i>// Zeit zählen
</i>  <b>if</b> (iRestTime--) <b>return</b>(1);
  <i>// Fertig; Objekt entfernen
</i>  <b>return</b>(RemoveObject());
}

<b>protected</b> <b>func</b> Destruction()
{
  <i>// Zauber wird entfernt: Unsichtbarkeit aufheben
</i>  SetClrModulation(iOldModulation, pTarget);
  SetVisibility(iOldVisibility, pTarget);
  <b>return</b>(1);
}</pre>
	
	<div class="text">Das Zauberobjekt bleibt hier einfach so lange erhalten, bis die Zeit abgelaufen ist, und macht den Clonk dann wieder sichtbar. Die Sichtbarmachung im Destruction-Callback macht das Objekt auch wieder sichtbar, wenn das Objekt aus irgendwelchen Gründen (z.B. Wechsel der Szenariensektion) entfernt wurde - ansonsten bliebe der Clonk in dem Fall auf ewig unsichtbar. Außerdem wird ein Timer verwendet, bei dem davon ausgegangen wird, dass er in der DefCore definiert ist und jede Sekunde aufgerufen wird. Ein Timer mit einem Intervall in der Dauer der Unsichtbarkeit wäre übrigens nicht möglich gewesen, da die Objekt-Timer je nach Spielzeit an unterschielichen Zeiten im Intervall beginnen können. Um den Timer zu sparen, hätte man also eine Aktivität definieren müssen.</div>
	<div class="text">Dieses Script hat allerdings auch einige Probleme: Beispielsweise kann der Zauberer keinen weiteren Unsichtbarkeitszauber sprechen, während er unsichtbar ist. Der zweite Zauber wäre praktisch wirkungslos, weil der erste Zauber bei seinem Ablauf schon den Clonk sichtbar macht. Der Zauber müsste also eine Spezialbehandlung für diesen Fall einführen - aber nicht nur für diesen, sondern für alle anderen Zauber, die Sichtbarkeit oder Färbung des Clonks verändern. Zwar berechnet das Script eine vorherige Verfärbung mit ein, betrachtet aber nicht den Fall, dass ein anderer Effekt diese zwischenzeitlich ändern könnte. Dieselben Probleme ergäben sich, wenn mehrere Effekte auf Clonk-Physicals (Sprunghöhe, Laufgeschwindigkeit, Kampfstärke, usw.), Sichtradius, Energie, Zauberenergie oder sonstigen Status einwirken. Über Effekte kann dies umgangen werden.</div>
	
	<h2 id="Usage">Anwendung</h2>
	<div class="text">Effekte werden mit der Scriptfunktion <a href="../../sdk/script/fn/AddEffect.html">AddEffect</a> erstellt und analog mit <a href="../../sdk/script/fn/RemoveEffect.html">RemoveEffect</a> entfernt. Wenn ein Effekt erfolgreich zum Objekt hinzugefügt wurde, wird der Callback Fx*Start aufgerufen (* steht dabei für den Effektnamen). Je nach Parametern kann dann ein periodischer Aufruf von Fx*Timer erfolgen, in dem der Effekt Partikel sprühen, Lebensenergie abziehen oder sonstige Dinge tun kann. Schließlich erfolgt, wenn der Effekt entfernt wird, ein Aufruf Fx*Stop, durchgeführt, in dem sich der Effekt entfernen sollte. Als Beispiel hier der oben beschriebene Unsichtbarkeitszauber mit Effekten:</div>
	
	<pre class="code"><i>/* Unsichtbarkeitszauber mit Effektsystem */</i>
	
<b>#strict</b>

<i>// EffectVars:
</i><i>//   0 - Vorheriger Sichtbarkeitsstatus
</i><i>//   1 - Vorherige Farbmodulation
</i>
<b>public</b> <b>func</b> Activate(pCaster, pCaster2)
{
  <i>// Zauberer ermitteln
</i>  <b>if</b> (pCaster2) pCaster = pCaster2;
  <i>// Magie kann man hören, ganz klar ;)
</i>  Sound(<i class="string">"Magic*"</i>);
  <i>// Effekt starten
</i>  AddEffect(<i class="string">"InvisPSpell"</i>, pCaster, 200, 1111, 0, GetID());
  <i>// Fertig - das Zauberobjekt wird nun nicht mehr gebraucht
</i>  <b>return</b>(RemoveObject());
}

<b>protected</b> <b>func</b> FxInvisPSpellStart(pTarget, iEffectNumber)
{
  <i>// Vorherige Sichtbarkeit des Zauberers speichern
</i>  EffectVar(0, pTarget, iEffectNumber) = GetVisibility(pTarget);
  <b>var</b> iOldMod = EffectVar(1, pTarget, iEffectNumber) = GetClrModulation(pTarget);
  <i>// Zauberer unsichtbar machen
</i>  SetVisibility(VIS_Owner() | VIS_Allies() | VIS_God(), pTarget);
  <i>// Halbdurchsichtig bläulich für den Besitzer und Verbündete
</i>  SetClrModulation(ModulateColor(iOldMod, RGBa(127,127,255,127)), pTarget);
  <i>// Fertig
</i>  <b>return</b>(1);
}

<b>protected</b> <b>func</b> FxInvisPSpellStop(pTarget, iEffectNumber)
{
  <i>// Status wiederherstellen
</i>  SetClrModulation(EffectVar(1, pTarget, iEffectNumber), pTarget);
  SetVisibility(EffectVar(0, pTarget, iEffectNumber), pTarget);
  <i>// Fertig
</i>  <b>return</b>(1);
}</pre>
	
	<div class="text">Hier startet das Zauberobjekt nur noch den Effekt, und entfernt sich dann. Die Engine sorgt dafür, dass keine Probleme bei der Sichtbarkeit auftreten: Effekte werden in einem Stapel angelegt, der sicher stellt, dass jeder Effekte immer in der umgekehrten Reihenfolge entfernt werden, in der sie hinzugefügt wurden. Dazu sind ein paar zusätzliche Start- und Stop-Aufrufe notwendig, auf die später noch eingegangen wird.</div>
	<div class="text">Der Effekt hat außerdem keinen Timer-Aufruf, aber trotzdem ein angegebenes TimerIntervall von 1111. Das sorgt dafür, dass mit dem ersten Aufruf nach 1111 Frames der Standard-Timer ausgelöst wird, der den Effekt löscht. Alternativ hätte man auch eine Timerfunktion definieren können:</div>
	
	<pre class="code"><b>protected</b> <b>func</b> FxInvisPSpellTimer(pTarget, iEffectNumber)
{
  <i>// Rückgabewert -1 bedeutet, dass der Effekt gelöscht wird
</i>  <b>return</b>(-1);
}</pre>
	
	<div class="text">Zum Speichern der vorherigen Statuswerte des Effektziels wird der spezielle Speicherbereich in <a href="../../sdk/script/fn/EffectVar.html">EffectVar</a>() verwendet. Dies ist nötig, da die Effekt-Callbacks in diesem Fall keinen Befehlskontext haben. Es können also keine objektlokalen Variablen (<code>local</code>) verwendet werden - das Zauberobjekt wurde schließlich gelöscht. Falls ein Objektkontext benötigt wird, kann man diesen auch an <a href="../../sdk/script/fn/AddEffect.html">AddEffect</a>() übergeben. Die Aufrufe sind dann objektlokal, und der Effekt wird automatisch gelöscht, wenn das Befehlszielobjekt gelöscht wurde.</div>
	
	<h2 id="Priorities">Prioritäten</h2>
	<div class="text">Beim Erstellen eines Effektes wird immer eine Priorität mit angegeben, die die Überladungsreihenfolge der Effekte angibt. Die Engine garantiert dabei, dass Effekte mit niedriger Priorität immer vor Effekten mit hoher Priorität hinzugefügt werden - notfalls durch temporäres Entfernen von Effekten mit höherer Priorität. Wenn also ein Effekt einen Clonk grün färbt, und ein anderer rot, so wird das Ergebnis das des Effektes mit höherer Priorität sein, da dieser Effekt zuletzt angewendet wurde. Haben zwei Effekte die gleiche Priorität, ist die Reihenfolge nicht definiert. Es ist jedoch garantiert, dass später zugewiesene Effekte stets an den Fx*Effect-Callback gleicher Priorität mit übergeben werden.</div>
	<div class="text">Im Falle der Grün-/Rotfärbung von Clonks sollte ein Effekt natürlich möglichst die vorherige Färbung abfragen, und dann zum Beispiel mit ModulateColor mischen. Die Prioritäten haben allerdings noch eine weitere Funktion: Ein Effekt mit hoher Priorität kann das Hinzufügen anderer Effekte mit niedrigerer Priorität verhindern. Dazu dient der Callback Fx*Effect. Gibt irgendein Effekt als Reaktion auf diesen Callback -1 zurück, wird der neue Effekt nicht hinzugefügt (dasselbe gilt für den Start-Callback beim Effekt selber). Dazu ein Beispiel:</div>
	
	<pre class="code"><i>/* Feuerimmunitätszauber */</i>

<b>#strict</b>

<b>public</b> <b>func</b> Activate(pCaster, pCaster2)
{
  <i>// Zauberer ermitteln
</i>  <b>if</b> (pCaster2) pCaster = pCaster2;
  <i>// Magie kann man hören, ganz klar ;)
</i>  Sound(<i class="string">"Magic*"</i>);
  <i>// Effekt starten
</i>  AddEffect(<i class="string">"BanBurnPSpell"</i>, pCaster, 180, 1111, 0, GetID());
  <i>// Fertig - das Zauberobjekt wird nun nicht mehr gebraucht
</i>  <b>return</b>(RemoveObject());
}

<b>protected</b> <b>func</b> FxBanBurnPSpellStart(pTarget, iEffectNumber, iTemp)
{
  <i>// Beim Start des Effektes: Clonk löschen, wenn er brennt
</i>  <b>if</b> (!iTemp) Extinguish(pTarget);
  <b>return</b>(1);
}

<b>protected</b> <b>func</b> FxBanBurnPSpellEffect(szNewEffect, iEffectTarget, iEffectNumber, iNewEffectNumber, <b>var</b>1, <b>var</b>2, <b>var</b>3)
{
  <i>// Feuer abblocken
</i>  <b>if</b> (WildcardMatch(szNewEffect, <i class="string">"*Fire*"</i>)) <b>return</b>(-1);
  <i>// Alles andere ist OK
</i>  <b>return</b>();
}</pre>
	
	<div class="text">Dieser Zauber macht den Clonk für 30 Sekunden gegen Feuer immun. Der Effekt kommt ohne Timer- und Stop-Callbacks aus, da die gesamte Funktionalität schon im Abblocken aller Effekte besteht, die "Fire" als Teilzeichenkette enthalten. Dies gilt insbesondere auch für das engineinterne Feuer, das genau den Effektnamen "Fire" hat. Man könnte hier natürlich trotzdem einen Timer für grafische Effekte hinzufügen, damit der Spieler sieht, dass er gerade nicht brennen kann. Außerdem könnte beim Abblocken eines Feuers in FxBanBurnPSpellEffect zusätzliche Effekte ausführen, wie zum Beispiel:</div>
	
	<pre class="code">[...]

<b>protected</b> <b>func</b> FxBanBurnPSpellEffect(szNewEffect, iEffectTarget, iEffectNumber, iNewEffectNumber, <b>var</b>1, <b>var</b>2, <b>var</b>3)
{
  <i>// Nur Feuer behandeln
</i>  <b>if</b> (!WildcardMatch(szNewEffect, <i class="string">"*Fire*"</i>)) <b>return</b>();
  <i>// Beim Feuer haben die drei Extraparameter normalerweise folgende Bedeutung:
</i>  <i>// var1: iCausedBy           - Spieler, der für das Feuer verantwortlich ist
</i>  <i>// var2: fBlasted            - bool: Ob das Feuer durch eine Explosion zustande kam
</i>  <i>// var3: pIncineratingObject - Objekt: Anzündendes Objekt
</i>  <i>// Anzündendes Objekt löschen
</i>  <b>if</b> (<b>var</b>3 &amp;&amp; GetType(<b>var</b>3) == C4V_C4Object()) Extinguish(<b>var</b>3);
  <i>// Feuer abblocken
</i>  <b>return</b>(-1);
}</pre>
	
	<div class="text">Dies würde sogar alle brennenden Objekte löschen, die das Zielobjekt ansonsten anzünden würden. Der Typecheck für var3 ist enthalten, weil sich andere Effekte ebenfalls Fire in den Namen setzen und andere Parameter haben könnten. Es ist offensichtlich, dass man dies vermeiden sollte, weil Funktionen wie die obige dann im ungünstigsten Fall ein völlig anderes Objekt löschen könnten.</div>
	<div class="text">Die folgende Tabelle enthält grobe Richtlinien für Prioritäten von Originalpackeffekten:</div>
	
	<div class="text"><table>
<thead><tr>
<th>Effekt</th>
<th>Priorität</th>
</tr></thead>
<tbody>
<tr>
<td>Kurzer Spezialeffekt</td>
<td>300-350</td>
</tr>
<tr class="dark">
<td>Nicht bannbare Effekte</td>
<td>250-300</td>
</tr>
<tr>
<td>Magie-Bannzauber</td>
<td>200-250</td>
</tr>
<tr class="dark">
<td>Andauernde Magie-Bannzauber</td>
<td>180-200</td>
</tr>
<tr>
<td>Kurzfristige, positive Zaubereffekte</td>
<td>150-180</td>
</tr>
<tr class="dark">
<td>Kurzfristige, negative Zaubereffekte</td>
<td>120-150</td>
</tr>
<tr>
<td>Normale Effekte</td>
<td>100-120</td>
</tr>
<tr class="dark">
<td>Engineinternes Feuer</td>
<td>100</td>
</tr>
<tr>
<td>Permanente Zaubereffekte</td>
<td>50-100</td>
</tr>
<tr class="dark">
<td>Permanente, sonstige Effekte</td>
<td>20-50</td>
</tr>
<tr>
<td>Interne Effekte als Datenspeicher, etc.</td>
<td>1</td>
</tr>
</tbody>
</table></div>
	
	<div class="text">Allgemein richten sich Effekte natürlich erst einmal nach den Abhängigkeiten: Wenn ein Effekt einen anderen verhindern soll, braucht der verhindernde Effekt höhere Priorität (Selbst wenn es ein permanenter Effekt ist). Dann sollten kurzfristige Effekte gegenüber den längerfristigen eine höhere Priorität bekommen, damit die kurzfristigen Statusänderungen bei demselben Statuselement gegenüber den langfristigen Statuselementen eher zu sehen sind.</div>
	<div class="text">Das engineinterne Feuer liegt natürlich fest bei 100. Ein magisches Feuer, das die Eigenschaften des engineinternen Feuers auch benutzt, sollte entsprechend leicht darüber liegen, und in allen seinen Callbacks die entsprechenden FxFire*-Aufrufe mit aufrufen. Dabei sollten stets alle Callbacks (also Start, Timer und Stop) weitergeleitet werden, da diese voneinander abhängen und sich diese Abhängigkeiten auch in verschiedenen Engineversionen verschieben können. Wenn das nicht geht, sollte das Verhalten besser gleich komplett per Script emuliert werden.</div>
	
	<div class="text">Effekte mit Priorität 1 sind ein Spezialfall: Für sie werden nie andere Effekte temporär entfernt und sie selber werden ebenfalls nie temporär entfernt.</div>
	
	<h2 id="SpecAddRemove">Spezielle Add/Remove-Aufrufe</h2>
	<div class="text">Damit die Engine sicherstellen kann, dass Effekte immer in umgekehrter Reihenfolge entfernt werden, wie sie hinzugefügt wurden, müssen zuweilen Effekte temporär entfernt und wieder hinzugefügt werden. In diesen Aufrufen sollte der Scripter natürlich alle Statuszustände löschen und wiederherstellen, damit sich die anderen Effekte danach ausrichten können. Aktionen, die nur einmal beim Starten oder enden des Effektes ausgeführt werden sollen. Dazu gehört zum Beispiel das Löschen des Zielobjektes beim letzten Beispielscript, oder auch Soundeffekte.</div>
	<div class="text">Effekte werden auch dann entfernt, wenn das Zielobjekt entfernt wird oder stirbt - der Grund wird im iReason-Parameter an die Remove-Funktion der Effekte übergeben. Auf diese Weise kann man beispielsweise dafür sorgen, dass ein Clonk nach dem Sterben sofort wiederbelebt wird:</div>
	
	<pre class="code"><i>/* Wiederbelebungszauber */</i>

<b>#strict</b>

<i>// EffectVars: 0 - Anzahl der zusätzlichen Wiederbelebungen
</i>
<b>public</b> <b>func</b> Activate(pCaster, pCaster2)
{
  <i>// Zauberer ermitteln
</i>  <b>if</b> (pCaster2) pCaster = pCaster2;
  <i>// Magie kann man hören, ganz klar ;)
</i>  Sound(<i class="string">"Magic*"</i>);
  <i>// Effekt starten
</i>  AddEffect(<i class="string">"ReincarnationPSpell"</i>, pCaster, 180, 0, 0, GetID());
  <i>// Fertig - das Zauberobjekt wird nun nicht mehr gebraucht
</i>  <b>return</b>(RemoveObject());
}

<b>protected</b> <b>func</b> FxReincarnationPSpellStart(pTarget, iEffectNumber, iTemp)
{
  <i>// Nur beim ersten Start: Meldung
</i>  <b>if</b> (!iTemp) Message(<i class="string">"%s bekommt|ein Extraleben"</i>, pTarget, GetName(pTarget));
  <b>return</b>(1);
}

<b>protected</b> <b>func</b> FxReincarnationPSpellStop(pTarget, iEffectNumber, iReason, fTemp)
{
  <i>// Nur beim Tod des Clonks
</i>  <b>if</b> (iReason != 4) <b>return</b>(1);
  <i>// Effekt erhalten, wenn der Clonk lebt: Wurde wohl durch einen anderen Effekt wiederbelebt :)
</i>  <b>if</b> (GetAlive(pTarget)) <b>return</b>(-1);
  <i>// Clonk wiederbeleben
</i>  SetAlive(1, pTarget);
  <i>// Energie geben
</i>  DoEnergy(100, pTarget);
  <i>// Nachricht
</i>  Sound(<i class="string">"Magic*"</i>, 0, pTarget);
  Message(<i class="string">"%s|wurde wiederbelebt."</i>, pTarget, GetName(pTarget));
  <i>// Effekt wirkt nur einmal: Entfernen
</i>  <b>return</b>(1);
}</pre>
	
	<div class="text">Dieser Effekt belebt den Clonk beim Tod so oft wieder, wie er den Zauber gesprochen hat.</div>
	
	<h2 id="GlobalEffects">Globale Effekte</h2>
	<div class="text">Globale Effekte sind einfach Effekte, die an kein Zielobjekt gebunden sind. Innerhalb der globalen Effekte werden aber trotzdem Prioritäten beachtet und temporäre Add/Remove-Aufrufe durchgeführt. Man kann sich vorstellen, dass alle globalen Effekte an einem imaginären, globalen Objekt hängen. Globale Effekte werden entsprechend immer angesprochen, indem man an die Effektfunktionen als Zielobjekt 0 übergibt.</div>
	<div class="text">Hiermit lassen sich zum Beispiel Änderungen an der Gravitation, Himmelsfärbung, etc. durchführen. Ein Beispiel für einen Zauber, der die Gravitation reduziert und mit der Zeit wieder an den regulären Wert anpasst:</div>
	
	<pre class="code"><i>/* Gravitationszauber */</i>

<b>#strict</b>

<i>// EffectVars: 0 - Vorherige Gravitation
</i><i>//             1 - Änderung durch den Zauber
</i>
<b>public</b> <b>func</b> Activate(pCaster, pCaster2)
{
  <i>// Magie kann man hören, ganz klar ;)
</i>  Sound(<i class="string">"Magic*"</i>);
  <i>// Effekt global starten
</i>  AddEffect(<i class="string">"GravChangeUSpell"</i>, 0, 150, 37, 0, GetID(), -10);
  <i>// Fertig - das Zauberobjekt wird nun nicht mehr gebraucht
</i>  <b>return</b>(RemoveObject());
}

<b>protected</b> <b>func</b> FxGravChangeUSpellStart(pTarget, iEffectNumber, iTemp, iChange)
{
  <i>// Anderen Gravitationseffekt suchen
</i>  <b>if</b> (!iTemp)
  {
    <b>var</b> iOtherEffect = GetEffect(<i class="string">"GravChangeUSpell"</i>, pTarget);
    <b>if</b> (iOtherEffect == iEffectNumber) iOtherEffect = GetEffect(<i class="string">"GravChangeUSpell"</i>, pTarget, 1);
    <b>if</b> (iOtherEffect)
    {
      <i>// Gravitationsänderung auf diesen Effekt aufrechnen
</i>      EffectVar(1, pTarget, iOtherEffect) += iChange;
      SetGravity(GetGravity() + iChange);
      <i>// Selbst entfernen
</i>      <b>return</b>(-1);
    }
  }
  <i>// Vorherige Gravitation sichern
</i>  <b>var</b> iOldGrav = EffectVar(0, pTarget, iEffectNumber) = GetGravity();
  <i>// Für nichttemporäre Aufrufe wird iChange übergeben, und auf den Änderungswert aufgerechnet
</i>  <b>if</b> (iChange) EffectVar(1, pTarget, iEffectNumber) += iChange;
  <i>// Gravitationsänderung setzen
</i>  <i>// Die Änderung kann in temporären Aufrufen auch ungleich iChange sein
</i>  SetGravity(iOldGrav + EffectVar(1, pTarget, iEffectNumber));
  <i>// Fertig
</i>  <b>return</b>(1);
}

<b>protected</b> <b>func</b> FxGravChangeUSpellTimer(pTarget, iEffectNumber)
{
  <i>// Gravitation in Richtung Normalwert schrauben
</i>  <b>var</b> iGravChange = EffectVar(1, pTarget, iEffectNumber);
  <i>// Fertig?
</i>  <b>if</b> (Inside(iGravChange, -1, 1)) <b>return</b>(-1);
  <i>// Anpassen
</i>  <b>var</b> iDir = -iGravChange/Abs(iGravChange);
  EffectVar(1, pTarget, iEffectNumber) += iDir;
  SetGravity(GetGravity() + iDir);
  <b>return</b>(1);
}

<b>protected</b> <b>func</b> FxGravChangeUSpellStop(pTarget, iEffectNumber)
{
  <i>// Gravitation Wiederherstellen
</i>  SetGravity(EffectVar(0, pTarget, iEffectNumber));
  <i>// Effekt entfernen
</i>  <b>return</b>(1);
}</pre>
	
	<div class="text">pTarget wird hier in allen Effektaufrufen 0 sein. Trotzdem sollte der Parameter immer an Aufrufe wie <a href="../../sdk/script/fn/EffectVar.html">EffectVar</a>() übergeben werden, da es dann auch möglich ist, den Effekt an den Zauberer oder ggf. den Zauberturm zu binden. In diesem Fall würde die Gravitation automatisch zurückgesetzt, sobald der Zauberer stirbt oder der Turm gelöscht wird.</div>
	
	<h2 id="AddEffects">Zusammenfassen von Effekten</h2>
	<div class="text">Im letzten Beispiel wurden mehrere Gravitationseffekte zusammen gefasst, so dass die Änderung der Gravitation länger andauert, wenn mehrmals gezaubert wurde. Die Zusammenfassung durfte nicht im Effect-Callback passieren, da der Gravitationseffekt immer noch von einem Effekt mit höherer Priorität (beispielsweise ein keine-globalen-Zauber-erlauben-Effekt) abgelehnt werden könnte. Über den speziellen Fx*Add-Callback kann man dasselbe Ergebnis aber auch einfacher (oder zumindest übersichtlicher) erreichen:</div>
	
	<pre class="code">[...]

<b>protected</b> <b>func</b> FxGravChangeUSpellEffect(szNewEffect, pTarget, iEffectNumber)
{
  <i>// Falls der neu hinzugefügte Effekt auch eine Gravitationsänderung ist, Interesse am Übernehmen anmelden
</i>  <b>if</b> (szNewEffect eq <i class="string">"GravChangeUSpell"</i>) <b>return</b> (-3);
  <i>// Ansonsten ignorieren
</i>  <b>return</b>();
}

<b>protected</b> <b>func</b> FxGravChangeUSpellAdd(pTarget, iEffectNumber, szNewEffect, pTarget, iNewTimer, iChange)
{
  <i>// Aufruf erfolgt, wenn der Effekt übernommen werden konnte
</i>  <i>// Gravitationsänderung auf diesen Effekt aufrechnen
</i>  EffectVar(1, pTarget, iEffectNumber) += iChange;
  SetGravity(GetGravity() + iChange);  
  <i>// Fertig
</i>  <b>return</b>(1);
}</pre>
	
	<div class="text">Die Rückgabe von -3 an den Fx*Effect-Callback, sorgt dafür, dass der Fx*Add-Callback für den neuen Effekt ausgeführt wird. Der neue Effekt wird dabei nicht erzeugt, und die entsprechende AddEffect-Funktion gibt die Effektnummer des Effektes zurück, der den neuen Effekt übernommen hat. Die Methode hat gegenüber der weiter oben verwendeten also den Vorteil, dass der Rückgabewert von AddEffect benutzt werden kann, um festzustellen, ob der Effekt überhaupt erzeugt werden konnte.</div>
	
	<h2 id="UserCallbacks">Benutzerdefinierte Eigenschaften</h2>
	<div class="text">Viele Klassifizierungen von Effekten können einfach über den Namen geregelt werden. Auf diese Weise können beispielsweise schnell alle Zaubereffekte über Wildcards gesucht und entfernt werden. Falls man aber zum Beispiel eigene Eigenschaften definieren will, die auch für existierende Effekte gelten, kann man zusätzliche Effektfunktionen definieren:</div>
	
	<pre class="code"><b>global</b> <b>func</b> FxFireIsHot() { <b>return</b>(1); } <i>// Feuer is heiß
</i>
<i>// Funktion, die alle heißen Effekte vom Zielobjekt entfernt
</i><b>global</b> <b>func</b> RemoveAllHotEffects(pTarget)
{
  <i>// Lokaler Aufruf
</i>  <b>if</b> (!pTarget) pTarget=this();
  <i>// Alle Effekte durchsuchen und die heißen entfernen
</i>  <b>var</b> iEffect, i;
  <b>while</b> (iEffect = GetEffect(<i class="string">"*"</i>, pTarget, i++))
    <b>if</b> (EffectCall(pTarget, iEffect, <i class="string">"IsHot"</i>))
      RemoveEffect(0, pTarget, iEffect);
}</pre>
	
	<div class="text">Über <a href="../../sdk/script/fn/EffectCall.html">EffectCall</a>() können natürlich auch Funktionen im Effekt ausgelöst werden; beispielsweise um bestimmte Effekte zu verlängern.</div>
	
	<h2 id="BlendFx">Blindeffekte</h2>
	<div class="text">Manchmal müsste ein Effekt nur erzeugt werden, um die entsprechenden Callbacks in anderen Effekten auszuführen - beispielsweise bei Zaubern, die keine längere Animation benötigen, aber trotzdem durch andere Effekte blockiert können werden sollen. Ein Beispiel ist der Erdbebenzauber:</div>
	
	<pre class="code"><i>/* Erdbebenzauber */</i>

<b>#strict</b>

<b>public</b> <b>func</b> Activate(<b>object</b> pCaster, <b>object</b> pCaster2)
{
  Sound(<i class="string">"Magic1"</i>);
  <i>// Effekt prüfen
</i>  <b>var</b> iResult;
  <b>if</b> (iResult = CheckEffect(<i class="string">"EarthquakeNSpell"</i>, 0, 150)) <b>return</b>(iResult!=-1 &amp;&amp; RemoveObject());
  <i>// Effekt ausführen
</i>  <b>if</b> (GetDir(pCaster)==DIR_Left()) CastLeft(); <b>else</b> CastRight();
  <i>// Zauberobjekt entfernen
</i>  <b>return</b>(RemoveObject());
}</pre>
	
	<div class="text">Der Rückgabewert von <a href="../../sdk/script/fn/CheckEffect.html">CheckEffect</a>() ist -1 wenn der Effekt abgelehnt, und positiv oder -2 wenn er aufgenommen wurde. In beiden Fällen sollte der Effekt selber nicht ausgeführt werden; aber in letzterem Fall kann die Activate-Funktion Erfolg signalisieren und 1 zurückgeben.</div>
	
	<h2 id="Ext">Erweiterte Möglichkeiten</h2>
	<div class="text">Da jeder Effekt seinen eigenen Datenspeicher hat, ist dies eine Möglichkeit, extern Daten an Objekte zu binden, ohne dabei die Definitionen verändern zu müssen. Außerdem können so einfache Aufrufe verzögert durchgeführt werden - beispielsweise erst ein Frame nach der Zerstörung eines Objekts, wie an einer Stelle im Ritterpack:</div>
	
	<pre class="code"><i>// Der Aufruf von CastleChange muss verzögert erfolgen, damit das Teil zum Aufruf auch wirklich weg ist
</i><i>// Ansonsten würden FindObject()-Aufrufe dieses Objekt noch finden
</i><b>public</b> <b>func</b> CastlePartDestruction()
{
  <i>// Fundament?
</i>  <b>if</b> (basement) 
  	RemoveObject(basement);
  <i>// Globaler Temporäreffekt, wenn nicht schon vorhanden
</i>  <b>if</b> (!GetEffect(<i class="string">"IntCPW2CastleChange"</i>))
  	AddEffect(<i class="string">"IntCPW2CastleChange"</i>, 0, 1, 2, 0, CPW2);
  <b>return</b>(1);
}

<b>protected</b> <b>func</b> FxIntCPW2CastleChangeStop()
{
  <i>// Alle BurgTeile benachrichtigen
</i>  <b>var</b> pObj;
  <b>while</b>(pObj = FindObject(0, 0, 0, 0, 0, OCF_Fullcon(), 0,0, NoContainer(), pObj))
    pObj-&gt;~CastleChange();
  <i>// Fertig
</i>  <b>return</b>(1);
}</pre>
	
	<div class="text">Bei derartigen Effekten sollte der Name mit "Int" beginnen; insbesondere falls sie mit globalem Callback erzeugt werden, sollte darauf die ID des Objekts folgen, um Namenskollisionen zu vermeiden.</div>
	
	<div class="text">Zudem können bestimmte Aktionen beim Tod von Lebewesen ausgeführt werden, ohne dafür gleich eine neue Objektdefinition zu benötigen. In einem Szenarioscript kann beispielsweise stehen:</div>
	
	<pre class="code"><i>/* Szenarioscript */</i>

<b>#strict</b>

<b>protected</b> <b>func</b> Initialize()
{
  <i>// Alle Wipfe manipulieren
</i>  <b>var</b> obj;
  <b>while</b> (obj = FindObject(WIPF, 0,0,0,0, OCF_Alive(), 0,0, 0, obj))
    AddEffect(<i class="string">"ExplodeOnDeathCurse"</i>, obj, 20);
}

<b>global</b> <b>func</b> FxExplodeOnDeathCurseStop(pTarget, iEffectNumber, iReason)
{
  <i>// Bumm!
</i>  <b>if</b> (iReason == 4) Explode(20, pTarget);
  <b>return</b>(1);
}</pre>

	<div class="text">Alle Wipfe, die von Anfang an im Szenario waren, explodieren beim Tod.</div>
	
	<h2 id="Naming">Benennung</h2>
	<div class="text">Damit sich Effekte untereinander erkennen und manipulieren können, sollten folgende Benennungsschemata verwendet werden ("*abc" steht für Endungen, "abc*" für Namensanfänge und "*abc*" für Zeichenketten, die irgendwo im Namen vorkommen sollten.</div>
	
	<div class="text"><table>
<thead><tr>
<th>Namensteil</th>
<th>Bedeutung</th>
</tr></thead>
<tbody>
<tr>
<td>*Spell</td>
<td>Magischer Effekt</td>
</tr>
<tr class="dark">
<td>*PSpell</td>
<td>Für das Zielobjekt positiver, magischer Effekt</td>
</tr>
<tr>
<td>*NSpell</td>
<td>Für das Zielobjekt negativer, magischer Effekt</td>
</tr>
<tr class="dark">
<td>*USpell</td>
<td>Neutraler, magischer Effekt</td>
</tr>
<tr>
<td>*Fire*</td>
<td>Feuereffekt - die Funktion <a href="../../sdk/script/fn/Extinguish.html">Extinguish</a>() entfernt alle Effekte dieser Maske.</td>
</tr>
<tr class="dark">
<td>*Curse*</td>
<td>Fluch</td>
</tr>
<tr>
<td>*Ban*</td>
<td>Effekt, der andere Effekte bannt (z.B. Feuer- oder Zauberimmunität)</td>
</tr>
<tr class="dark">
<td>Int*</td>
<td>Interner Effekt (Variablenspeicher, etc.)</td>
</tr>
<tr>
<td>*Potion</td>
<td>Zaubertrank</td>
</tr>
</tbody>
</table></div>
	
	<div class="text">Achtung: Da Funktionsnamen maximal 100 Zeichen lang sein dürfen (und irgendwann auch die Übersicht verloren geht), sollte man nicht endlos Statusinformationen in den Namen packen. Alle Effektfunktionen unterscheiden zwischen Groß- und Kleinschreibung. Umgekehrt sollte man vermeiden, die entsprechenden Zeichenketten im Effektnamen vorkommen zu lassen, wenn sie nichts mit den jeweiligen Bedeutungen zu tun haben.</div>
	
	<h2 id="CBRef">Callback-Referenz</h2>
	
		<div class="text">Folgenge Callbacks werden von der Engine ausgeführt, und sollten - je nach Bedarf - im Script implementiert werden. * steht jeweils für den Effektnamen.</div>
		
		<h3>Fx*Start</h3>
		<div class="text"><code><b>int</b> Fx*Start (<b>object</b> pTarget, <b>int</b> iEffectNumber, <b>int</b> iTemp, C4Value <b>var</b>1, C4Value <b>var</b>2, C4Value <b>var</b>3, C4Value <b>var</b>4);</code></div>
		<div class="text">Wird beim Start des Effektes aufgerufen. pTarget gibt das Zielobjekt des Effektes an, und iEffectNumber den Index. Über diese beiden Parameter lässt sich der Effekt eindeutig identifizieren, um beispielsweise zugehörige Variablen in <a href="../../sdk/script/fn/EffectVar.html">EffectVar</a>() zu manipulieren.</div>
		<div class="text">Der Parameter iTemp ist 0 beim normalen Hinzufügen des Effektes, 1 wenn der Effekt nur hinzugefügt wird, weil er vorher temporär entfernt wurde, und 2 wenn der Effekt hinzugefügt wird, weil er zuvor temporär entfernt wurde aber jetzt selber gelöscht werden soll (in dem Fall folgt dann ein Remove-Aufruf).</div>
		<div class="text">Die Werte var1 bis var4 entsprechen den übergebenen Parametern an <a href="../../sdk/script/fn/AddEffect.html">AddEffect</a>(), und können verwendet werden, um Effekte mit unterschiedlichen Eigenschaften zu erzeugen.</div>
		<div class="text">Wenn iTemp 0 ist und dieser Callback -1 zurückgibt, wird der Effekt nicht erzeugt und der zugehörige <a href="../../sdk/script/fn/AddEffect.html">AddEffect</a>()-Aufruf gibt 0 zurück.</div>
		
		<h3>Fx*Stop</h3>
		<div class="text"><code><b>int</b> Fx*Stop (<b>object</b> pTarget, <b>int</b> iEffectNumber, <b>int</b> iReason, <b>bool</b> fTemp);</code></div>
		<div class="text">Aufruf, wenn der Effekt temporär oder permanent entfernt wird. pTarget ist wieder das Effekt-Zielobjekt und iEffectNumber der Effektindex in der Effekteliste des Objekts.</div>
		<div class="text">iReason gibt den Grund für das Entfernen des Effektes an, und kann einer der folgenden Werte sein:</div>
		
		<div class="text"><table>
<thead><tr>
<th>iReason</th>
<th>Bedeutung</th>
</tr></thead>
<tbody>
<tr>
<td>0</td>
<td>Effekt wird regulär entfernt</td>
</tr>
<tr class="dark">
<td>1</td>
<td>Effekt wird nur temporär entfernt. fTemp ist in dem Fall 1.</td>
</tr>
<tr>
<td>2</td>
<td>nicht verwendet</td>
</tr>
<tr class="dark">
<td>3</td>
<td>Effekt wird entfernt, weil das Objekt gelöscht wird</td>
</tr>
<tr>
<td>4</td>
<td>Effekt wird entfernt, weil das Objekt stirbt</td>
</tr>
</tbody>
</table></div>
		
		<div class="text">Wenn der Effekt nicht gelöscht werden soll, kann in der Funktion -1 zurückgegeben werden, um das Löschen zu verhindern. Bei temporären Aufrufen oder wenn das Zielobjekt gelöscht wird, bringt dies natürlich nichts.</div>
		
		<h3>Fx*Timer</h3>
		<div class="text"><code><b>int</b> Fx*Timer (<b>object</b> pTarget, <b>int</b> iEffectNumber, <b>int</b> iEffectTime);</code></div>
		<div class="text">Periodischer Timer-Aufruf, wenn bei der Effekterzeugung ein Timer-Intervall angegeben wurde. pTarget und iEffectNumber spezifizieren auch hier Zielobjekt und Effekt.</div>
		<div class="text">iEffectTime gibt die die Zeit an, die der Effekt schon läuft. Diese lässt sich auch über <a href="../../sdk/script/fn/GetEffect.html">GetEffect</a>() mit entsprechenden Parametern abfragen.</div>
		<div class="text">Ein Rückgabewert von -1 bedeutet, dass der Effekt nach dem Aufruf gelöscht wird. Dasselbe passiert, wenn die Funktion nicht implementiert wird.</div>
		
		
		<h3>Fx*Effect</h3>
		<div class="text"><code><b>int</b> Fx*Effect (<b>string</b> szNewEffectName, <b>object</b> pTarget, <b>int</b> iEffectNumber, <b>int</b> iNewEffectNumber, C4Value <b>var</b>1, C4Value <b>var</b>2, C4Value <b>var</b>3, C4Value <b>var</b>4);</code></div>
		<div class="text">Aufruf an alle Effekte mit höherer Priorität, wenn ein neuer Effekt zu demselben Objekt (pTarget) hinzugefügt werden soll. szNewEffectName gibt den Namen des neuen Effektes an; iEffectNumber den Effektindex des Effektes, bei dem angefragt wird, und iNewEffectNumber den Index des neu zu erzeugenden Effektes.</div>
		<div class="text">Achtung: Der neue Effekt ist noch nicht fertig initialisiert, und sollte daher nicht manipuliert werden. Insbesondere das Priority-Feld ist möglicherweise noch nicht initialisiert. Der iNewEffectNumber-Parameter kann aber verwendet werden, um mit <a href="../../sdk/script/fn/EffectCall.html">EffectCall</a>() Informationen über den Effekt abzufragen. Bei Aufrufen durch die <a href="../../sdk/script/fn/CheckEffect.html">CheckEffect</a>()-Funktion ist iNewEffectNumber 0.</div>
		<div class="text">Die Funktion sollte -1 zurückgeben, wenn sie den neuen Effekt ablehnt. Da der Effekt auch noch von einem anderen Effekt abgelehnt werden kann, sollte dieser Callback nicht dazu verwendet werden, um beispielsweise Effekte zusammenzufassen (siehe Beispiel zum Gravitationszauber). Überhaupt sollte es möglichst vermieden werden, in diesem Aufruf die Effektliste zu manipulieren.</div>
		<div class="text">Ein Rückgabewert von -2 oder -3 sollte angegeben werden, wenn der Effekt übernommen wird. Sofern der Effekt dann von keinem anderen Effekt abgelehnt wurde (über Rückgabewert -1), wird ein Fx*Add-Aufruf an den übernehmenden Effekt gesendet, der neue Effekt selber entfernt, und die aufrufende AddEffect-Funktion erhält als Rückgabewert die Nummer des übernehmenden Effektes. Rückgabewert -3 bedeutet dabei im Gegensatz zu -2, dass vor dem Fx*Add-Aufruf alle Effekte mit höherer Priorität temporär entfernt, und nach dem Aufruf dieselben wieder temporär hinzugefügt werden.</div>
		<div class="text">var1 bis var4 sind die Parameter, die an die <a href="../../sdk/script/fn/AddEffect.html">AddEffect</a>()-Funktion übergeben wurden.</div>
		
		<h3>Fx*Add</h3>
		<div class="text"><code><b>int</b> Fx*Add (<b>object</b> pTarget, <b>int</b> iEffectNumber, <b>string</b> szNewEffectName, <b>int</b> iNewEffectTimer, C4Value <b>var</b>1, C4Value <b>var</b>2, C4Value <b>var</b>3, C4Value <b>var</b>4);</code></div>
		<div class="text">Aufruf an einen übernehmenden Effekt, wenn dieser zuvor auf einen Fx*Effect-Callback hin -2 oder -3 zurückgegeben hat. iEffectNumber gibt die Nummer des Effektes an, zu dem hinzugefügt wird; pTarget das Zielobjekt (0 bei globalen Effekten).</div>
		<div class="text">iNewEffectTimer ist das Timer-Intervall des neu erzeugten Effektes; var1 bis var4 die an AddEffect übergebenen Zusatzparameter. ACHTUNG: Diese Zusatzparameter werden natürlich nicht bei temporären Aufrufen übergeben, sondern sind dann 0.</div>
		<div class="text">Wird -1 zurückgegeben, wird auch der übernehmende Effekt entfernt. Logischerweise gibt die erzeugende AddEffect-Funktion dann -2 zurück.</div>
		
		<h3>Fx*Damage</h3>
		<div class="text"><code><b>int</b> Fx*Damage (<b>object</b> pTarget, <b>int</b> iEffectNumber, <b>int</b> iDmgEngy, <b>int</b> iCause, <b>int</b> iCausePlr);</code></div>
		<div class="text">Jeder Effekt erhält diesen Callback, wann immer sich der Energie- oder Schadenswert des Zielobjektes ändert. Falls die Funktion definiert wird, sollte der Rückgabewert dabei die erlaubte Änderung angeben.</div>
		<div class="text">iDmgEngy gibt die Änderung an. Negative Werte geben Schaden an, Positive Werte Heilung (im Falle von Lebewesen).</div>
		<div class="text">Werte für die Energie sind dabei exakt, das heißt 100.000 entspricht der vollen Energie eines normalen Clonks mit Rang 10 (C4MaxPhysical).
		Der Umrechnungsfaktor zwischen GetEnergy und diesem Wert ist 1.000.
		</div>
		<div class="text">Der Callback wird bei Energiewertänderungen bei Lebewesen, sowie bei Schadenswertänderungen bei nicht-Lebewesen durchgeführt - nicht aber umgekehrt. iCause gibt den geänderten Wert und den Grund an:</div>
		
		<div class="text"><table>
<thead><tr>
<th>Scriptkonstante</th>
<th>iCause</th>
<th>Bedeutung</th>
</tr></thead>
<tbody>
<tr>
<td>FX_Call_DmgScript</td>
<td>0</td>
<td>Schaden durch Scriptaufruf <a href="../../sdk/script/fn/DoDamage.html">DoDamage</a>()</td>
</tr>
<tr class="dark">
<td>FX_Call_DmgBlast</td>
<td>1</td>
<td>Schaden durch Explosion</td>
</tr>
<tr>
<td>FX_Call_DmgFire</td>
<td>2</td>
<td>Schaden durch Feuer</td>
</tr>
<tr class="dark">
<td>FX_Call_DmgChop</td>
<td>3</td>
<td>Schaden durch Fällen (nur Bäume)</td>
</tr>
<tr>
<td>FX_Call_EngScript</td>
<td>32</td>
<td>Energieänderung durch Scriptaufruf <a href="../../sdk/script/fn/DoEnergy.html">DoEnergy</a>()</td>
</tr>
<tr class="dark">
<td>FX_Call_EngBlast</td>
<td>33</td>
<td>Energieverlust durch Explosion</td>
</tr>
<tr>
<td>FX_Call_EngObjHit</td>
<td>34</td>
<td>Energieverlust durch Objekttreffer</td>
</tr>
<tr class="dark">
<td>FX_Call_EngFire</td>
<td>35</td>
<td>Energieverlust durch Feuer</td>
</tr>
<tr>
<td>FX_Call_EngBaseRefresh</td>
<td>36</td>
<td>Energieaufnahme in der Basis - auch Abgabe und Kauf der Basis, wenn die Basis ein Lebewesen ist</td>
</tr>
<tr class="dark">
<td>FX_Call_EngAsphyxiation</td>
<td>37</td>
<td>Energieverlust durch Ersticken</td>
</tr>
<tr>
<td>FX_Call_EngCorrosion</td>
<td>38</td>
<td>Energieverlust durch Säure</td>
</tr>
<tr class="dark">
<td>FX_Call_EngStruct</td>
<td>39</td>
<td>Energieverlust von Gebäuden (Nur lebende Gebäude)</td>
</tr>
<tr>
<td>FX_Call_EngGetPunched</td>
<td>40</td>
<td>Energieverlust im Clonk-zu-Clonk-Kampf</td>
</tr>
</tbody>
</table></div>

		<div class="text">Allgemein kann der Ausdruck "iCause &amp; 32" verwendet werden, um festzustellen, ob Energie oder Schadenswert verändert wurden.</div>
		<div class="text">iCausePlr gibt die Spielernummer des verursachenden Spielers.</div>
		<div class="text">Über diesen Callback kann zum Beispiel Schaden an einem Objekt verhindert, abgeschwächt oder verstärkt werden; man kann Lebensschaden zunächst nur von der Zauberenergie abziehen, gleichmäßig auf verbundene Clonks verteilen und so weiter.</div>
		
		<h3>Fx*Info</h3>
		<div class="text"><code><b>int</b> Fx*Info(<b>object</b> pTarget, <b>int</b> iEffectNumber)</code></div>
		<div class="text">Wird aufgerufen, wenn via Kontextmenü die Infos eines Objektes, das das Ziel dieses Effektes ist, abgefragt werden.</div>
	
	
	<h2 id="FnRef">Funktions-Referenz</h2>
	<div class="text">Es gibt folgende Funktionen sind zum Manipulieren und Abfragen von Effekten:</div>
	
	<div class="text"><ul>
		<li>
<a href="../../sdk/script/fn/AddEffect.html">AddEffect</a>() - zum Erzeugen von Effekten</li>
		<li>
<a href="../../sdk/script/fn/RemoveEffect.html">RemoveEffect</a>() - zum Entfernen von Effekten</li>
		<li>
<a href="../../sdk/script/fn/GetEffect.html">GetEffect</a>() - zum Abfragen von Effekten und Parametern</li>
		<li>
<a href="../../sdk/script/fn/GetEffectCount.html">GetEffectCount</a>() - um Effekte zu zählen</li>
		<li>
<a href="../../sdk/script/fn/EffectCall.html">EffectCall</a>() - für Benutzeraufrufe in Effekten</li>
		<li>
<a href="../../sdk/script/fn/EffectVar.html">EffectVar</a>() - zum Abfragen von Effektvariablen</li>
		<li>
<a href="../../sdk/script/fn/ChangeEffect.html">ChangeEffect</a>() - zum Ändern von Effektnamen und -timern (beispielsweise für mehrstufige Effekte)</li>
		<li>
<a href="../../sdk/script/fn/CheckEffect.html">CheckEffect</a>() - um Effekt-Callbacks auszuführen, ohne den Effekt selber zu erstellen</li>
	</ul></div>


<div class="author">Sven2, März 2004</div>

<?php 
  pwn_body(basename (dirname(__FILE__)) . basename(__FILE__,".html"), $_SERVER['SCRIPT_NAME']);
?><ul class="nav">
<li class="fineprint">Clonk Entwicklermodus Dokumentation</li>
<li class="switchlang"><a href="javascript:switchLanguage()"><img src="/deco/dco_en_sml.gif" alt="English" border="0"></a></li>
<li><a href="../../sdk/index.html">Einleitung</a></li>
<li><a href="../../content.html">Inhalt</a></li>
<li><a href="../../search.php">Suche</a></li>
<li><a href="../../sdk/console.html">Engine</a></li>
<li><a href="../../sdk/cmdline.html">Kommandozeile</a></li>
<li><a href="../../sdk/files.html">Spieldaten</a></li>
<li><a href="../../sdk/script/index.html">Script</a></li>
</ul>
</body>
</html>
